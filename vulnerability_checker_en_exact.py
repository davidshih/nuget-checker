#!/usr/bin/env python3
"""
NuGet Package Vulnerability Checker - Exact Version Matching
This version only checks for exact version matches, no fuzzy or conservative matching.
"""

import requests
import pandas as pd
import time
from packaging import version
from typing import List, Dict, Optional
from concurrent.futures import ThreadPoolExecutor, as_completed
import re

class VulnerabilityCheckerExact:
    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'NuGet-Vulnerability-Scanner-Exact/1.0'
        })
    
    def search_nvd(self, package_name: str, version: Optional[str] = None) -> List[Dict]:
        """Search NVD (National Vulnerability Database) with exact version matching"""
        vulnerabilities = []
        
        try:
            print(f"\nğŸ” Searching NVD for {package_name}...")
            
            base_url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
            params = {
                'keywordSearch': package_name,
                'keywordExactMatch': 'true',  # Use exact matching
                'resultsPerPage': 100
            }
            
            response = self.session.get(base_url, params=params, timeout=30)
            if response.status_code == 200:
                data = response.json()
                
                for item in data.get('vulnerabilities', []):
                    cve_data = item.get('cve', {})
                    
                    # Only check if we have a version to match
                    if version and self._is_exact_version_match(package_name, version, cve_data):
                        # Extract CVSS score (prefer v3, fallback to v2)
                        cvss_score = 0.0
                        severity = "UNKNOWN"
                        
                        metrics = cve_data.get('metrics', {})
                        if 'cvssMetricV31' in metrics:
                            cvss_data = metrics['cvssMetricV31'][0]['cvssData']
                            cvss_score = cvss_data.get('baseScore', 0.0)
                            severity = cvss_data.get('baseSeverity', 'UNKNOWN')
                        elif 'cvssMetricV30' in metrics:
                            cvss_data = metrics['cvssMetricV30'][0]['cvssData']
                            cvss_score = cvss_data.get('baseScore', 0.0)
                            severity = cvss_data.get('baseSeverity', 'UNKNOWN')
                        elif 'cvssMetricV2' in metrics:
                            cvss_data = metrics['cvssMetricV2'][0]['cvssData']
                            cvss_score = cvss_data.get('baseScore', 0.0)
                            severity = self._convert_cvss_v2_severity(cvss_score)
                        
                        # Build vulnerability info
                        vulnerabilities.append({
                            'source': 'NVD',
                            'cve_id': cve_data.get('id', 'N/A'),
                            'cvss_score': cvss_score,
                            'severity': severity,
                            'description': cve_data.get('descriptions', [{}])[0].get('value', 'N/A'),
                            'link': f"https://nvd.nist.gov/vuln/detail/{cve_data.get('id', '')}"
                        })
            
            # Rate limiting
            time.sleep(0.5)
            
        except Exception as e:
            print(f"  âŒ NVD search error: {e}")
        
        return vulnerabilities
    
    def _is_exact_version_match(self, package_name: str, pkg_version: str, cve_data: Dict) -> bool:
        """Check if the exact version is affected by CVE"""
        try:
            # Parse package version
            current_version = version.parse(pkg_version)
            
            # Check version info in CVE description
            description = cve_data.get('descriptions', [{}])[0].get('value', '').lower()
            
            # Look for exact version mentions
            version_patterns = [
                # "version X.Y.Z"
                rf'version\s+{re.escape(pkg_version)}(?:\s|,|\.)',
                # "v X.Y.Z"
                rf'v\s*{re.escape(pkg_version)}(?:\s|,|\.)',
                # "X.Y.Z version"
                rf'{re.escape(pkg_version)}\s+version',
                # Just the version number with boundaries
                rf'\b{re.escape(pkg_version)}\b'
            ]
            
            # Check configurations for exact version match
            configurations = cve_data.get('configurations', [])
            for config in configurations:
                nodes = config.get('nodes', [])
                for node in nodes:
                    cpe_match = node.get('cpeMatch', [])
                    for cpe in cpe_match:
                        # Check if this CPE entry matches our exact version
                        if self._check_cpe_exact_version(cpe, package_name, pkg_version):
                            print(f"  âœ… Exact version match found in CPE: {pkg_version}")
                            return True
            
            # Check if exact version is mentioned in description
            for pattern in version_patterns:
                if re.search(pattern, description):
                    if package_name.lower() in description:
                        print(f"  âœ… Exact version match found in description: {pkg_version}")
                        return True
            
            print(f"  âŒ No exact version match for {pkg_version}")
            return False
            
        except Exception as e:
            print(f"  âŒ Version parsing error: {e}")
            return False
    
    def _check_cpe_exact_version(self, cpe_entry: Dict, package_name: str, version_str: str) -> bool:
        """Check if CPE entry matches exact version"""
        criteria = cpe_entry.get('criteria', '')
        
        # Extract version from CPE string (format: cpe:2.3:a:vendor:product:version:...)
        cpe_parts = criteria.split(':')
        if len(cpe_parts) >= 6:
            cpe_version = cpe_parts[5]
            if cpe_version == version_str:
                # Also check if package name matches
                cpe_product = cpe_parts[4]
                if package_name.lower() in cpe_product.lower() or cpe_product.lower() in package_name.lower():
                    return True
        
        # Check version start/end if they define an exact match
        version_start = cpe_entry.get('versionStartIncluding')
        version_end = cpe_entry.get('versionEndIncluding')
        
        if version_start == version_str and version_end == version_str:
            return True
        
        return False
    
    def _convert_cvss_v2_severity(self, score: float) -> str:
        """Convert CVSS v2 score to severity level"""
        if score >= 7.0:
            return "HIGH"
        elif score >= 4.0:
            return "MEDIUM"
        else:
            return "LOW"
    
    def _estimate_cvss_from_severity(self, severity: str) -> float:
        """Estimate CVSS score from severity string"""
        severity_map = {
            'CRITICAL': 9.0,
            'HIGH': 7.5,
            'MEDIUM': 5.0,
            'LOW': 2.5,
            'UNKNOWN': 0.0
        }
        return severity_map.get(severity.upper(), 0.0)
    
    def search_github_advisory(self, package_name: str, version: Optional[str] = None) -> List[Dict]:
        """Search GitHub Advisory Database with exact version matching"""
        vulnerabilities = []
        
        try:
            print(f"  ğŸ” Searching GitHub Advisory for {package_name}...")
            
            # GitHub Advisory GraphQL API requires authentication
            # Using REST API as fallback (limited results)
            
            # Note: For full functionality, GitHub token would be needed
            # This is a simplified implementation
            
            # Since GitHub token is needed, we use public REST API instead
            search_url = f"https://api.github.com/search/repositories"
            params = {
                'q': f"{package_name} vulnerability",
                'sort': 'updated',
                'per_page': 10
            }
            
            response = self.session.get(search_url, params=params, timeout=10)
            if response.status_code == 200:
                # Simplified handling here, actual implementation may need more complex logic
                pass
            
            time.sleep(0.5)
        except Exception as e:
            print(f"GitHub Advisory search error: {e}")
        
        return vulnerabilities
    
    def search_osv(self, package_name: str, version: Optional[str] = None) -> List[Dict]:
        """Search OSV (Open Source Vulnerabilities) with exact version matching"""
        vulnerabilities = []
        try:
            url = "https://api.osv.dev/v1/query"
            
            # Build query with exact version
            query_data = {
                "package": {
                    "name": package_name,
                    "ecosystem": "NuGet"
                }
            }
            
            if version:
                query_data["package"]["version"] = version
            
            response = self.session.post(url, json=query_data, timeout=10)
            if response.status_code == 200:
                data = response.json()
                for vuln in data.get('vulns', []):
                    # Check if this vulnerability affects our exact version
                    if version and self._check_osv_exact_version(vuln, version):
                        # Calculate CVSS score (OSV may not provide directly)
                        severity = vuln.get('database_specific', {}).get('severity', 'UNKNOWN')
                        cvss_score = self._estimate_cvss_from_severity(severity)
                        
                        vulnerabilities.append({
                            'source': 'OSV',
                            'cve_id': vuln.get('id', 'N/A'),
                            'cvss_score': cvss_score,
                            'severity': severity,
                            'description': vuln.get('summary', 'N/A'),
                            'link': f"https://osv.dev/vulnerability/{vuln.get('id', '')}"
                        })
            
            time.sleep(0.5)
        except Exception as e:
            print(f"OSV search error: {e}")
        
        return vulnerabilities
    
    def _check_osv_exact_version(self, vuln: Dict, version_str: str) -> bool:
        """Check if OSV vulnerability affects exact version"""
        affected = vuln.get('affected', [])
        
        for pkg in affected:
            if pkg.get('package', {}).get('ecosystem') == 'NuGet':
                versions = pkg.get('versions', [])
                if version_str in versions:
                    return True
                
                # Check ranges for exact match
                ranges = pkg.get('ranges', [])
                for range_info in ranges:
                    events = range_info.get('events', [])
                    for event in events:
                        if 'fixed' in event and event['fixed'] == version_str:
                            # If this version is the fix, it's not affected
                            return False
                        if 'introduced' in event and event['introduced'] == version_str:
                            # If this version introduced the vuln, it's affected
                            return True
        
        return False
    
    def search_snyk(self, package_name: str, version: Optional[str] = None) -> List[Dict]:
        """Search Snyk Vulnerability Database"""
        vulnerabilities = []
        try:
            # Snyk public API (limited)
            url = f"https://security.snyk.io/package/nuget/{package_name}"
            
            # Since Snyk requires API key, this is a mock search
            # In actual use, you need to register for Snyk account and get API key
            
            time.sleep(0.5)
        except Exception as e:
            print(f"Snyk search error: {e}")
        
        return vulnerabilities
    
    def check_vulnerabilities(self, packages: List[str]) -> List[Dict]:
        """Check vulnerabilities for multiple packages with exact version matching"""
        all_vulnerabilities = []
        
        for package in packages:
            package = package.strip()
            if not package:
                continue
            
            # Parse package name and version
            name = package
            version = None
            
            # Support multiple formats: package.version, package-version, package/version
            patterns = [
                r'^(.+?)\.(\d+(?:\.\d+)*)$',  # package.version
                r'^(.+?)-(\d+(?:\.\d+)*)$',   # package-version
                r'^(.+?)/(\d+(?:\.\d+)*)$',   # package/version
            ]
            
            for pattern in patterns:
                match = re.match(pattern, package)
                if match:
                    name = match.group(1)
                    version = match.group(2)
                    break
            
            # Remove .nupkg extension if present
            if name.endswith('.nupkg'):
                name = name[:-6]
            
            print(f"\nğŸ” Checking package: {name} (version: {version or 'not specified'})")
            
            # Only search if we have a version (exact matching requires version)
            if not version:
                print(f"  âš ï¸  No version specified for {name}, skipping (exact version matching mode)")
                continue
            
            # Parallel search across multiple sources
            sources_checked = []
            package_vulnerabilities = []
            
            with ThreadPoolExecutor(max_workers=4) as executor:
                futures = {
                    executor.submit(self.search_nvd, name, version): 'NVD',
                    executor.submit(self.search_github_advisory, name, version): 'GitHub Advisory',
                    executor.submit(self.search_osv, name, version): 'OSV',
                    executor.submit(self.search_snyk, name, version): 'Snyk'
                }
                
                for future in as_completed(futures):
                    source = futures[future]
                    try:
                        vulnerabilities = future.result()
                        sources_checked.append(f"âœ… {source}")
                        
                        if vulnerabilities:
                            print(f"  ğŸ” {source}: Found {len(vulnerabilities)} vulnerabilities")
                            for vuln in vulnerabilities:
                                vuln['package'] = name
                                vuln['package_version'] = version
                            package_vulnerabilities.extend(vulnerabilities)
                        else:
                            print(f"  ğŸ” {source}: No vulnerabilities")
                            
                    except Exception as e:
                        sources_checked.append(f"âŒ {source}")
                        print(f"  âŒ {source}: Search failed - {e}")
            
            # Display data source summary
            print(f"  ğŸ“Š Data sources checked: {', '.join(sources_checked)}")
            print(f"  ğŸ“‹ Package {name} total vulnerabilities found: {len(package_vulnerabilities)}")
            print()
            
            all_vulnerabilities.extend(package_vulnerabilities)
        
        # Sort by CVSS score (high to low)
        all_vulnerabilities.sort(key=lambda x: x.get('cvss_score', 0), reverse=True)
        
        return all_vulnerabilities

if __name__ == "__main__":
    # Test cases
    checker = VulnerabilityCheckerExact()
    test_packages = ["serilog.4.3.0", "newtonsoft.json.13.0.1"]
    results = checker.check_vulnerabilities(test_packages)
    
    for vuln in results:
        print(f"Package: {vuln['package']}")
        print(f"Version: {vuln['package_version']}")
        print(f"CVE: {vuln['cve_id']}")
        print(f"CVSS: {vuln['cvss_score']}")
        print(f"Severity: {vuln['severity']}")
        print(f"Source: {vuln['source']}")
        print(f"Link: {vuln['link']}")
        print("-" * 50)